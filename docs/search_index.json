[["index.html", "Guide to Using Census Data 1 Census Data", " Guide to Using Census Data Ryan Brenner Updated: Thursday, December 04, 2025 at 01:38 PM 1 Census Data Article I, Section 2, Clause 3 of the US Constitution requires that the actual Enumeration [for apportioning Representatives] shall be made within three Years after the first Meeting of the Congress of the United States, and within every subsequent Term of ten Years, in such Manner as they shall by Law direct. The first meeting of the Congress of the United States took place in 1789, the first enumeration was conducted in 1790, and a count has been taken every subsequent term of ten years as the Decennial Census ever since. U.S. marshals initially tabulated Census data, then trained enumerators took over in 1880 with in-person interviews, and finally households began completing their own questionnaires in 1960 when the Census began distributing forms by mail. The Census was first administered under the Secretary of State, then moved to the Department of the Interior in 1849, and finally shifted in 1902 to a newly established permanent Census Office within the Department of Commerce and Labor, the predecessor of todays Department of Commerce and the modern U.S. Census Bureau. Over time, the Census has expanded from a simple headcount with only six questions related to age, sex, and race into a broad statistical system that now includes more than 200 separate surveys. The scope of the Decennial Census gradually expanded throughout the 1800s to include manufacturing, agriculture (including slavery), and natural resource extraction. The 1890 Decennial Census was the first to join administrative data to supplement enumeration records, opening the Census to broader demographic and statistical uses beyond the constitutional requirement. In the 1940s, statistical sampling was first used to send a long form questionnaire to a subset of households, bifurcating the Decennial Census into a true census for enumeration and a survey estimate for all other information. In 2010, the long form was removed from the Decennial Census and became the American Community Survey, a detailed survey sent to a sample of households annually. The Congressional Research Service divides the Census Bureaus contemporary work into two accounts: (1) Periodic Censuses and Programs and (2) Current Surveys and Programs. The Periodic Censuses and Programs include some of the most well-known Census products: Decennial Census of Population and Housing: the constitutionally required, full enumeration that produces the population count used for apportionment, redistricting, and baseline demographic figures. American Community Survey (ACS): the continuous, sample-based survey that replaced the decennial long form, providing detailed characteristics on social, economic, housing, and demographic conditions. Economic Census: a comprehensive count of U.S. business activity conducted every five years, producing structural information about industries, employment, sales, and the economic composition of the country. Census of Governments: a comprehensive inventory conducted every five years of federal, state, and local governments, including their employment, finances, structures, and activities. The Current Surveys and Programs include the continuous, between-census data collections and tabulations that produce the nations primary demographic and economic indicators: Population Estimates Program (PEP): annual official estimates of population totals (i.e., adjustments from the Decennial Census), used in funding formulas, planning, and demographic analysis. Survey of Income and Program Participation (SIPP): a major panel survey that tracks income, program eligibility, benefit dynamics, and economic well-being over time. Current Population Survey (CPS): a monthly labor-force survey (conducted jointly with BLS) producing the official source for unemployment rates, labor-force participation, and related labor statistics. The remainder of this guide walks through basic usage of Census data. Sources Congressional Research Service Census Overview Library of Congress Census Resource Guide Census Bureau Survey and Census History Census Bureau Developing Sampling Techniques Census Bureau American Community Survey History Timeline "],["understanding-census-geographies.html", "2 Understanding Census Geographies 2.1 Background 2.2 Nested Geographies 2.3 Non-Nesting Geographies", " 2 Understanding Census Geographies Census data (aside from microdata sources like IPUMS) is never released at the individual level and is always aggregated to a geographic unit as counts, sums, medians, or binned distributions. As a result, selecting a survey product and variables also requires choosing the geographic level at which those variables will be reported. Smaller geographic units generally have higher margins of error, and some variables are unavailable at the smallest scales. Analyses that rely on these small units often use ACS 5-year estimates to pool five years of responses and improve accuracy. Beyond data availability, the appropriate geographic level depends on the projects unit of analysis and overall analytical design. While Census blocks and tracts form the building blocks of all geographic levels at which Census data is reported, not all geographic levels perfectly nest. Nested geographies refers to the hierarchical spine from Census block to nation, where each unit at a lower level is fully contained within a single unit at the next level up, and each higher-level unit is completely partitioned into lower-level units. Non-nesting geographies still rely on Census blocks and tracts, but their boundaries sometimes cross those of higher levels (e.g., metropolitan statistical areas cross state lines, places like New York City cross county lines). Although Census blocks, tracts, and certain geographies such as congressional districts are collaboratively delineated so that Census data can be accurately aggregated to those geographies, many other geographies are defined independently (e.g., ZIP Codes). Because these independently defined units cannot be directly aggregated from Census blocks and tracks, the Census Bureau produces tabulation areas (e.g., ZCTAs) that approximate non-Census geographies using Census blocks and tracts. As a specific tabulation area becomes more widely used, the Census Bureau sometimes works with the managers of the approximated geography to better reflect the geography with Census blocks and tracts (e.g., the Census Bureau working with NYC DCP to redraw block and tract boundaries to better reflect Community Districts). 2.1 Background The U.S. is composed of states and territories whose borders were fixed at the time of their admission to the union. With few exceptions, every state and territory is fully subdivided into counties or county-equivalent jurisdictions (e.g., parishes in Louisiana, boroughs in Alaska, and municipios in Puerto Rico). States and territories all contain various forms of local government (e.g., cities, towns, and villages), though some states have counties entirely partitioned into local governments (e.g., towns in New York) while others maintain extensive unincorporated areas with no municipal government below the county level (e.g., unincorporated Los Angeles County). Historically, the Census has always reported data for these higher-level geographies. Aside from larger cities with legally defined wards, Census data was not reported for smaller geographies until the end of the nineteenth century. For the 1890 Census, the federal government worked with several cities to establish sanitary districts, a new sub-ward level designed to provide more granular data for geographies with no independent legal status. These became the first small-area geographies ever reported by the Census, but the approach was abandoned in 1900. Meanwhile, settlement house researchers and other Progressive Era reformers were producing their own statistical neighborhoods and pressing the Census Bureau to adopt a consistent neighborhood-level reporting system. In the early 1900s, Dr. Walter Laidlaw attempted to use New York State Assembly Districts to study neighborhood conditions in NYC. When the state redrew its district boundaries in 1905, he concluded that assembly districts were too unstable for long-term demographic analysis. Thus, in 1906 he published a paper proposing a system of permanent small areas with boundaries that would remain consistent between Censuses. He then persuaded the newly created Census Bureau to pilot the idea in the 1910 Census, producing tract tabulations for NYC as well as Baltimore, Boston, Chicago, Cleveland, Philadelphia, Pittsburgh, and St. Louis. The group expanded for the 1930 Census to include Los Angeles, Columbus, Nashville, Berkeley, Syracuse, and Yonkers. In 1931, the American Statistical Association formed a Committee on Census Enumeration Areas and appointed Howard Whipple Green as chair; Mr. Green spent the next twenty-five years encouraging cities nationwide to adopt and use the new tracts. Institutionally, the Census Bureau standardized the tract delineation process in 1934. For the 1940 Census, it also began reporting block-level data for all cities with at least 50,000 residents. In cities where Census tracts already existed, blocks were nested within them; in cities without tracts, the Bureau created block areas (renamed block numbering areas (BNAs) in 1960) to function as equivalent geographies to tracts. During the 1970s and 1980s, BNAs expanded across much of the country, with the 1990 Census being the first to assign every part of the US to both a Census block and a tract/BNA. The 2000 Census then retired the BNA system entirely and converted all BNAs into Census tracts. 2.2 Nested Geographies Taking full advantage of the nesting of these geographies, the Census Bureau labels units in each level with GEOIDs that build upon the GEOIDs of higher levels of geography so the full code string contains information: Level GEOID Structure Digits Example Area Example GEOID State STATE 2 New York 36 County STATE+COUNTY 2+3=5 New York, NY (Manhattan) 36081 Census Tract STATE+COUNTY+TRACT 2+3+6=11 Census Tract 65 in New York, NY 36081006500 Census Block Group STATE+COUNTY+TRACT+FIRST DIGIT OF BLOCK 2+3+6+1=12 Block Group 1 in Census Tract 65 in New York, NY 360810065001 Census Block STATE+COUNTY+TRACT+BLOCK 2+3+6+4=15 Block 1006 in Census Tract 65 in New York, NY 360810065001006 2.2.1 Nation tidycensus term = us 2.2.2 Region tidycensus term = region 2.3 Non-Nesting Geographies Sources Census Bureau History of Census Tracts and Blocks Census Bureau Geographic Glossary Census Bureau Hierarchies Census Bureau GEOIDS "],["comparing-geographies-across-time.html", "3 Comparing Geographies Across Time", " 3 Comparing Geographies Across Time "],["querying-decennial-and-acs-data-with-tidycensus.html", "4 Querying Decennial and ACS Data with tidycensus", " 4 Querying Decennial and ACS Data with tidycensus "],["querying-nyc-hvs-data.html", "5 Querying NYC HVS Data 5.1 Survey Design 5.2 Variables 5.3 Examples", " 5 Querying NYC HVS Data library(tidyverse) library(srvyr) library(DT) #All HVS PUF Datasets all23 &lt;- readr::read_csv(&quot;https://www.nyc.gov/assets/hpd/data/allunits_puf_23.csv&quot;) occ23 &lt;- readr::read_csv(&quot;https://www.nyc.gov/assets/hpd/data/occupied_puf_23.csv&quot;) vac23 &lt;- readr::read_csv(&quot;https://www.nyc.gov/assets/hpd/data/vacant_puf_23.csv&quot;) per23 &lt;- readr::read_csv(&quot;https://www.nyc.gov/assets/hpd/data/person_puf_23.csv&quot;) The NYC Housing and Vacancy Survey (HVS) is a comprehensive housing survey conducted approximately every three years by the U.S. Census Bureau on behalf of the NYC Department of Housing Preservation and Development (HPD). Established in 1965, the HVS was created in response to the Citys Rent Stabilization Law, which requires periodic measurement of the citywide rental vacancy rate to determine whether a housing emergency exists. Beyond its legal function, the survey serves as the citys primary source of detailed data on housing conditions, affordability, and demographics. It collects information on occupancy status, rent, utilities, income, building age, and physical quality, among many other variables. The HVS provides a unique longitudinal record of New Yorks housing stock and is considered one of the most detailed local housing datasets in the United States. In the wake of Donald Trumps election and subsequent efforts to restrict access to federal data, the administration removed or suppressed numerous websites and datasets from agencies such as the Census Bureau. In response, responsibility for hosting and maintaining public access shifted into the hands of NYCs HPD, ensuring continued public access and stewardship of this vital housing data tool. As such, all information about the survey, as well as the survey data itself, is located here: https://www.nyc.gov/site/hpd/about/research.page There are four public use files that provide microdata to work with: The CONTROL variable joins all of the tables together, with every housing unit in the All Units dataset being in either Occupied Units or Vacant Units, and every person living in an Occupied Unit showing up as their own row in the Persons dataset (i.e., many-to-one match). Projects should start by identifying the universe of interest (all, occupied, or vacant units) and then left join to that dataset (using CONTROL as the key) to pull in variables from other datasets. 5.1 Survey Design Unlike the American Community Survey (ACS), which provides thousands of pre-calculated indicators in ready-made tables and crosstabs, the HVS is released primarily as raw microdata. Each record represents an individual housing unit or person, requiring users to construct their own measures and apply statistical weights to produce representative estimates. Working with the HVS therefore involves a more hands-on analytical process: users must merge datasets, define variables, and apply survey design adjustments using software capable of complex survey processing, such as Rs srvyr package. This structure makes the HVS both more flexible and more demanding, allowing researchers to generate customized analyses while maintaining methodological rigor. The optimal workflow is (1) decide on a universe of housing units, (2) pull together needed variables from the different files, and (3) convert the dataframe to a replicate-weighted survey design object (using pre-set arguments outlined in the HVS documentation): occ23 %&gt;% dplyr::left_join( all23 %&gt;% dplyr::select(CONTROL, CSR), by = &quot;CONTROL&quot;) %&gt;% srvyr::as_survey_rep( weights = FW, repweights = num_range(&quot;FW&quot;, 1:80), type = &quot;other&quot;, combined_weights = TRUE, scale = 4/80, rscales = 1, mse = TRUE ) ## Call: Called via srvyr ## with 80 replicates and MSE variances. ## Sampling variables: ## - repweights: `FW1 + FW2 + FW3 + FW4 + FW5 + FW6 + FW7 + FW8 + FW9 + FW10 + FW11 + FW12 + FW13 + FW14 + FW15 + FW16 + ## FW17 + FW18 + FW19 + FW20 + FW21 + FW22 + FW23 + FW24 + FW25 + FW26 + FW27 + FW28 + FW29 + FW30 + FW31 + FW32 + FW33 ## + FW34 + FW35 + FW36 + FW37 + FW38 + FW39 + FW40 + FW41 + FW42 + FW43 + FW44 + FW45 + FW46 + FW47 + FW48 + FW49 + ## FW50 + FW51 + FW52 + FW53 + FW54 + FW55 + FW56 + FW57 + FW58 + FW59 + FW60 + FW61 + FW62 + FW63 + FW64 + FW65 + FW66 ## + FW67 + FW68 + FW69 + FW70 + FW71 + FW72 + FW73 + FW74 + FW75 + FW76 + FW77 + FW78 + FW79 + FW80` ## - weights: FW ## Data variables: ## - CONTROL (dbl), TENURE (dbl), HHSIZE (dbl), HH62PLUS (dbl), HHUNDER18 (dbl), HHUNDER6 (dbl), HHFIRSTMOVEIN (dbl), ## HHDEAR (dbl), HHDEYE (dbl), HHDREM (dbl), HHDPHY (dbl), HHDDRS (dbl), HHDOUT (dbl), HHDONEPLUS (dbl), MOD_HAVE ## (dbl), MOD_NEED (dbl), UNIT_RATING (dbl), EXTERM_FREQ (dbl), NOHEAT (dbl), NOHEAT_NUM (dbl), FIX_311 (dbl), ## NOHOTWATER (dbl), ADDHEAT (dbl), LEAKS (dbl), MOLD (dbl), MUSTY (dbl), ELEVATOR_BROK (dbl), ELEVATOR_ALLBROK (dbl), ## RODENTS_UNIT (dbl), RODENTS_BUILD (dbl), TOILET_BROK (dbl), ROACHES_NUM (dbl), WALLHOLES (dbl), FLOORHOLES (dbl), ## PEELPAINT (dbl), PEELPAINT_LARGE (dbl), HPROBCOUNT (dbl), ACUNIT (dbl), AC_OFF (dbl), TEMP_HOT (dbl), ANIMS (dbl), ## SERVICEANIMAL (dbl), PETTYPE_DOG (dbl), PETTYPE_CAT (dbl), PETTYPE_OTHER (dbl), PA_FOOD (dbl), PA_CASH (dbl), ## PA_OTHER (dbl), PA_ANY (dbl), FOODINSECURE (dbl), UTIL_ELECTRIC (dbl), UTIL_GAS (dbl), UTIL_HEAT (dbl), UTIL_WATER ## (dbl), UTIL_INCLUDED (dbl), UTIL_NONE (dbl), UTILCOSTS_SUMMER (dbl), UTILCOSTS_WINTER (dbl), UTILCOSTS_HEAT (dbl), ## UTILCOSTS_WATER (dbl), MUTIL (dbl), INTERUPT_UTIL (dbl), INTERUPT_PHONE (dbl), INTERUPT_CELL (dbl), INTERUPT_NONE ## (dbl), HHINC_REC1 (dbl), HUDILFY22 (dbl), HUDILFY23 (dbl), HHPOVERTY (dbl), LEASENOW (dbl), LEASEEVER (dbl), ## LEASE_LENGTH (dbl), LEASE_START (dbl), RENTASSIST (dbl), RENTASSIST_VOUCHER (dbl), RENTOUTSIDE (dbl), RENTFEES ## (dbl), RENTFEES_AMOUNT (dbl), RENT_AMOUNT (dbl), GRENT (dbl), RENTPAID (dbl), RENTPAID_AMOUNT (dbl), MISSRENT (dbl), ## MISSRENT_NUM (dbl), STILL_OWE (dbl), ALTRENT_CREDIT (dbl), ALTRENT_SAVINGS (dbl), ALTRENT_LOAN (dbl), ALTRENT_ASSET ## (dbl), ALTRENT_OTHER (dbl), ALTRENT_ONEPLUS (dbl), RENTCREDIT_PAIDOFF (dbl), RENTBURDEN_CAT (dbl), INHERIT (dbl), ## OWNEROUT (dbl), FIRSTTIMEOWNER (dbl), RECENT_DOWNPAY (dbl), HELPDOWNPAY_PROG (dbl), HELPDOWNPAY_GIFT (dbl), ## HELPDOWNPAY_NONE (dbl), HDEBT_FIRSTMORT (dbl), HDEBT_ADDL (dbl), HDEBT_NONE (dbl), INT_FIRSTMORT (dbl), MFIRSTMORT ## (dbl), MOWNERCOST (dbl), HINSURE_AMT (dbl), HFLOODINSURE (dbl), HFLOODINSURE_AMT (dbl), HOFINSURE_AMT (dbl), ## LATEMORTGAGE (dbl), HHMORTDEDUCT (dbl), TOTAL_FIRSTMORT (dbl), ASSESSMENT (dbl), ASSESSMENT_AMT (dbl), CROWD_BDRM ## (dbl), CROWD_RM (dbl), HHCOVIDDIAG (dbl), NABE_MOVED (dbl), NABENOW_RATE (dbl), NABETHEN_RATE (dbl), SAFETY_RATE ## (dbl), HHLANG_EN (dbl), HHLANG_SP (dbl), HHLANG_HC (dbl), HHLANG_RU (dbl), HHLANG_BN (dbl), HHLANG_CH (dbl), ## HHLANG_NONENG (dbl), I_NOHEAT (dbl), I_NOHEAT_NUM (dbl), I_ADDHEAT (dbl), I_LEAKS (dbl), I_RODENTS_UNIT (dbl), ## I_RODENTS_BUILD (dbl), I_TOILET_BROK (dbl), I_WALLHOLES (dbl), I_FLOORHOLES (dbl), I_PEELPAINT (dbl), ## I_PEELPAINT_LARGE (dbl), I_UTIL_ELECTRIC (dbl), I_UTIL_GAS (dbl), I_UTIL_HEAT (dbl), I_UTIL_WATER (dbl), I_UTIL_NONE ## (dbl), I_UTIL_INCLUDED (dbl), I_UTILCOSTS_HEAT (dbl), I_UTILCOSTS_WATER (dbl), I_UTILCOSTS_WINTER (dbl), ## I_UTILCOSTS_SUMMER (dbl), FLG_I_MUTIL (dbl), FLG_I_HHINC_REC1 (dbl), I_RENTOUTSIDE (dbl), I_RENT_AMOUNT (dbl), ## I_RENTPAID (dbl), I_RENTPAID_AMOUNT (dbl), FLG_I_GRENT (dbl), I_HDEBT_FIRSTMORT (dbl), I_HDEBT_ADDL (dbl), ## I_HDEBT_NONE (dbl), FLG_I_MFIRSTMORT (dbl), FLG_INT_FIRSTMORT (dbl), FLG_I_MOWNERCOST (dbl), FLG_TC_MUTIL (dbl), ## FLG_TC_PA_INC (dbl), FLG_TC_HHINC_REC1 (dbl), FLG_TC_GRENT (dbl), I_TOTAL_FIRSTMORT (dbl), FLG_TC_MORTG (dbl), FW ## (dbl), FW1 (dbl), FW2 (dbl), FW3 (dbl), FW4 (dbl), FW5 (dbl), FW6 (dbl), FW7 (dbl), FW8 (dbl), FW9 (dbl), FW10 ## (dbl), FW11 (dbl), FW12 (dbl), FW13 (dbl), FW14 (dbl), FW15 (dbl), FW16 (dbl), FW17 (dbl), FW18 (dbl), FW19 (dbl), ## FW20 (dbl), FW21 (dbl), FW22 (dbl), FW23 (dbl), FW24 (dbl), FW25 (dbl), FW26 (dbl), FW27 (dbl), FW28 (dbl), FW29 ## (dbl), FW30 (dbl), FW31 (dbl), FW32 (dbl), FW33 (dbl), FW34 (dbl), FW35 (dbl), FW36 (dbl), FW37 (dbl), FW38 (dbl), ## FW39 (dbl), FW40 (dbl), FW41 (dbl), FW42 (dbl), FW43 (dbl), FW44 (dbl), FW45 (dbl), FW46 (dbl), FW47 (dbl), FW48 ## (dbl), FW49 (dbl), FW50 (dbl), FW51 (dbl), FW52 (dbl), FW53 (dbl), FW54 (dbl), FW55 (dbl), FW56 (dbl), FW57 (dbl), ## FW58 (dbl), FW59 (dbl), FW60 (dbl), FW61 (dbl), FW62 (dbl), FW63 (dbl), FW64 (dbl), FW65 (dbl), FW66 (dbl), FW67 ## (dbl), FW68 (dbl), FW69 (dbl), FW70 (dbl), FW71 (dbl), FW72 (dbl), FW73 (dbl), FW74 (dbl), FW75 (dbl), FW76 (dbl), ## FW77 (dbl), FW78 (dbl), FW79 (dbl), FW80 (dbl), CSR (chr) Once the dataset is converted into a replicate-weighted survey design object, R recognizes each observation as part of a complex survey sample rather than as an independent data point. This structure enables design-based analysis, allowing estimates, variances, and confidence intervals to reflect the HVSs sampling methodology. With this object in place, researchers can use tidyverse-style verbs such as summarize() with functions from srvyr like: survey_total() for counts survey_total(col) for sums survey_mean(col) for means survey_median(col) for medians survey_quantile(col, quantiles = x) for other quantiles Etc. occ23 %&gt;% srvyr::as_survey_rep( weights = FW, repweights = num_range(&quot;FW&quot;, 1:80), type = &quot;other&quot;, combined_weights = TRUE, scale = 4/80, rscales = 1, mse = TRUE ) %&gt;% dplyr::summarize( .by = TENURE, count = srvyr::survey_total(), median_hhsize = srvyr::survey_median(HHSIZE) ) %&gt;% DT::datatable() %&gt;% DT::formatRound(c(&quot;count&quot;, &quot;median_hhsize&quot;), digits = 0) %&gt;% DT::formatRound(c(&quot;count_se&quot;, &quot;median_hhsize_se&quot;), digits = 1) 5.2 Variables The HVS Codebook is the central reference for identifying, locating, and interpreting variables in the survey. It lists every variable and indicates which of the four datasets it is stored in, making it the first place to look when selecting variables or joining data across files. Because all responses are stored as numeric codes rather than text, the Codebook is also necessary for translating these values into their intended meanings and for avoiding common misreadings that can distort results. Commonly used variables include the following: 5.2.1 Borough (All Units) all23 %&gt;% dplyr::mutate( boro = dplyr::case_when( BORO == 1 ~ &quot;Bronx&quot;, BORO == 2 ~ &quot;Brooklyn&quot;, BORO == 3 ~ &quot;Manhattan&quot;, BORO == 4 ~ &quot;Queens&quot;, BORO == 5 ~ &quot;Staten Island&quot; ) ) 5.2.2 Regulatory Status (All Units) all23 %&gt;% dplyr::mutate( bldg_type = dplyr::case_when( #Renters CSR == &quot;05&quot; ~ &quot;NYCHA&quot;, CSR == &quot;32&quot; ~ &quot;Rent Stabilized&quot;, CSR == &quot;90&quot; ~ &quot;Rent Controlled&quot;, CSR == &quot;97&quot; ~ &quot;Other Subsidized/Regulated Rental&quot;, CSR == &quot;80&quot; ~ &quot;Private/Unregulated Rental&quot;, #Owners CSR == &quot;02&quot; ~ &quot;Coop&quot;, CSR == &quot;12&quot; ~ &quot;Condo&quot;, CSR == &quot;96&quot; ~ &quot;Subsidized/Regulated Owner-Occupied&quot;, CSR == &quot;06&quot; ~ &quot;Other Owner-Occupied&quot;, #Vacant CSR == &quot;03&quot; ~ &quot;Vacant, for Sale&quot;, CSR == &quot;04&quot; ~ &quot;Vacant, not for Sale&quot; ) ) 5.2.3 Year Built (All Units) all23 %&gt;% dplyr::mutate( year_built = dplyr::case_when( YEARBUILT == 1 ~ &quot;1900 or earlier&quot;, YEARBUILT == 2 ~ &quot;1901 to 1919&quot;, YEARBUILT == 3 ~ &quot;1920 to 1929&quot;, YEARBUILT == 4 ~ &quot;1930 to 1946&quot;, YEARBUILT == 5 ~ &quot;1947 to 1959&quot;, YEARBUILT == 6 ~ &quot;1960 to 1973&quot;, YEARBUILT == 7 ~ &quot;1974 to 1979&quot;, YEARBUILT == 8 ~ &quot;1980 to 1989&quot;, YEARBUILT == 9 ~ &quot;1990 to 1999&quot;, YEARBUILT == 10 ~ &quot;2000 to 2009&quot;, YEARBUILT == 11 ~ &quot;2010 or later&quot; ) ) 5.2.4 Units in Building (All Units) all23 %&gt;% dplyr::mutate( units = dplyr::case_when( UNITS == 1 ~ &quot;1 unit&quot;, UNITS == 2 ~ &quot;2 units&quot;, UNITS == 3 ~ &quot;3 units&quot;, UNITS == 4 ~ &quot;4-5 units&quot;, UNITS == 5 ~ &quot;6-9 units&quot;, UNITS == 6 ~ &quot;10-12 units&quot;, UNITS == 7 ~ &quot;13-19 units&quot;, UNITS == 8 ~ &quot;20-49 units&quot;, UNITS == 9 ~ &quot;50-99 units&quot;, UNITS == 10 ~ &quot;100+ units&quot; ) ) 5.2.5 Coop/Condos (All Units) all23 %&gt;% dplyr::mutate( coop_condo = dplyr::case_when( CONDOCOOP == -1 ~ &quot;Not reported&quot;, CONDOCOOP == 1 ~ &quot;Condo&quot;, CONDOCOOP == 2 ~ &quot;Coop&quot;, CONDOCOOP == 3 ~ &quot;Neither condo nor coop&quot; ) ) 5.2.6 Occupancy (All Units) all23 %&gt;% dplyr::mutate( occupancy = dplyr::case_when( OCC == 1 ~ &quot;Occupied&quot;, OCC == 2 ~ &quot;Vacant, available for rent&quot;, OCC == 3 ~ &quot;Vacant, not available for rent or sale&quot; ) ) 5.2.7 Tenure (Occupied) occ23 %&gt;% dplyr::mutate( tenure = dplyr::case_when( TENURE == 1 ~ &quot;Renter&quot;, TENURE == 2 ~ &quot;Owner&quot; ) ) 5.2.8 Household Income (Occupied) occ23 %&gt;% dplyr::mutate( #Range of values is -$40,000 to $500,000,000 hh_income = HHINC_REC1 ) 5.2.9 Rent (Occupied) occ23 %&gt;% dplyr::mutate( #Range of values is -2 (NA/owner-occupied) to $7,500 rent = RENT_AMOUNT ) 5.2.10 Voucher Use (Occupied) occ23 %&gt;% dplyr::mutate( voucher = dplyr::case_when( RENTASSIST_VOUCHER == -2 ~ &quot;Not applicable (owner)&quot;, RENTASSIST_VOUCHER == -1 ~ &quot;Not reported&quot;, RENTASSIST_VOUCHER == 1 ~ &quot;Has Section 8 / Housing Choice Voucher&quot;, RENTASSIST_VOUCHER == 2 ~ &quot;No Section 8 or Housing Choice Voucher&quot; ) ) 5.3 Examples 5.3.1 Count of Vacancy and Tenure all23 %&gt;% dplyr::mutate( occupancy = dplyr::case_when( OCC == 1 ~ &quot;Occupied&quot;, OCC == 2 ~ &quot;Vacant, available for rent&quot;, OCC == 3 ~ &quot;Vacant, not available for rent or sale&quot; ) ) %&gt;% dplyr::left_join( occ23 %&gt;% dplyr::transmute( CONTROL, tenure = dplyr::case_when( TENURE == 1 ~ &quot;Renter&quot;, TENURE == 2 ~ &quot;Owner&quot; ) ), by = &quot;CONTROL&quot; ) %&gt;% dplyr::mutate( status = dplyr::case_when( tenure == &quot;Owner&quot; ~ &quot;Occupied, owner&quot;, tenure == &quot;Renter&quot; ~ &quot;Occupied, renter&quot;, stringr::str_detect(occupancy, &quot;^Vacant,&quot;) ~ occupancy ) ) %&gt;% srvyr::as_survey_rep( weights = FW, repweights = num_range(&quot;FW&quot;, 1:80), type = &quot;other&quot;, combined_weights = TRUE, scale = 4/80, rscales = 1, mse = TRUE ) %&gt;% dplyr::summarize( .by = status, n = srvyr::survey_total(vartype = &quot;ci&quot;) ) %&gt;% DT::datatable() %&gt;% DT::formatRound(c(&quot;n&quot;, &quot;n_low&quot;, &quot;n_upp&quot;), digits = 0) 5.3.2 Median Rent by Regulation occ23 %&gt;% dplyr::filter( #Renters TENURE == 1, #Rent Reported RENT_AMOUNT &gt; 0 ) %&gt;% dplyr::left_join( all23 %&gt;% dplyr::transmute( CONTROL, bldg_type = dplyr::case_when( #Renters CSR == &quot;05&quot; ~ &quot;NYCHA&quot;, CSR == &quot;32&quot; ~ &quot;Rent Stabilized&quot;, CSR == &quot;90&quot; ~ &quot;Rent Controlled&quot;, CSR == &quot;97&quot; ~ &quot;Other Subsidized/Regulated&quot;, CSR == &quot;80&quot; ~ &quot;Private/Unregulated&quot;, #Owners CSR == &quot;02&quot; ~ NA_character_, CSR == &quot;12&quot; ~ NA_character_, CSR == &quot;96&quot; ~ NA_character_, CSR == &quot;06&quot; ~ NA_character_, #Vacant CSR == &quot;03&quot; ~ NA_character_, CSR == &quot;04&quot; ~ NA_character_ ) ), by = &quot;CONTROL&quot; ) %&gt;% srvyr::as_survey_rep( weights = FW, repweights = num_range(&quot;FW&quot;, 1:80), type = &quot;other&quot;, combined_weights = TRUE, scale = 4/80, rscales = 1, mse = TRUE ) %&gt;% dplyr::summarize( .by = bldg_type, median_rent = srvyr::survey_median(RENT_AMOUNT) ) %&gt;% ggplot( aes( x = reorder(bldg_type, median_rent), y = median_rent, ymin = median_rent - median_rent_se, ymax = median_rent + median_rent_se ) ) + geom_col(fill = &quot;dodgerblue3&quot;) + geom_errorbar(width = 0.2) + scale_y_continuous( expand = c(0, 0), limits = c(0, 2500), breaks = seq(0, 2500, 250), labels = scales::dollar_format(accuracy = 1) ) + labs( title = &quot;Median Rent by Rental Type&quot;, x = &quot;Type of Rental Unit&quot;, y = &quot;Median Rent (2023$)&quot;, caption = &quot;NYC Housing Vacancy Survey, 2023.&quot; ) + theme_minimal() "],["querying-microdata-with-ipums.html", "6 Querying Microdata with IPUMS 6.1 Extracting Data 6.2 Analyzing a Survey", " 6 Querying Microdata with IPUMS library(tidyverse) library(srvyr) library(DT) IPUMS, originally the Integrated Public Use Microdata Series, is a database of Census microdata housed at the Institute for Social Research and Data Innovation (ISRDI) at the University of Minnesota. Whereas the published tables of the American Community Survey (ACS) provide pre-calculated indicators and aggregated statistics for predefined geographies, IPUMS offers anonymized versions of the underlying person- and household-level records. Access to these raw microdata enables finer-grained analysis and the ability to create cross-tabulations of variables that are not combined in standard ACS products. Example The ACS surveys renter-occupied households about their rent. Whereas Table B25064 provides the median rent for a given geography, Table B25063 provides a distribution of rent amounts. However, the bins are pre-set with bin widths of $50 for rents under $800, $100 for rents under $1,000, $250 for rents under $1,500, $500 for rents under $3,500, and then a ceiling of $3,500. With a citywide median of around $1,700, these bin widths are not ideal for analyzing NYC rents. library(tidycensus) acs_rent &lt;- tidycensus::get_acs( geography = &quot;place&quot;, state = &quot;36&quot;, table = &quot;B25063&quot;, year = 2023, survey = &quot;acs1&quot; ) %&gt;% dplyr::filter(NAME == &quot;New York city, New York&quot;) %&gt;% dplyr::transmute( rent = dplyr::case_when( variable == &quot;B25063_001&quot; ~ &quot;DROP&quot;, #Total variable == &quot;B25063_002&quot; ~ &quot;DROP&quot;, #With cash rent variable == &quot;B25063_003&quot; ~ &quot;0-99&quot;, variable == &quot;B25063_004&quot; ~ &quot;100-149&quot;, variable == &quot;B25063_005&quot; ~ &quot;150-199&quot;, variable == &quot;B25063_006&quot; ~ &quot;200-249&quot;, variable == &quot;B25063_007&quot; ~ &quot;250-299&quot;, variable == &quot;B25063_008&quot; ~ &quot;300-349&quot;, variable == &quot;B25063_009&quot; ~ &quot;350-399&quot;, variable == &quot;B25063_010&quot; ~ &quot;400-449&quot;, variable == &quot;B25063_011&quot; ~ &quot;450-499&quot;, variable == &quot;B25063_012&quot; ~ &quot;500-549&quot;, variable == &quot;B25063_013&quot; ~ &quot;550-599&quot;, variable == &quot;B25063_014&quot; ~ &quot;600-649&quot;, variable == &quot;B25063_015&quot; ~ &quot;650-699&quot;, variable == &quot;B25063_016&quot; ~ &quot;700-749&quot;, variable == &quot;B25063_017&quot; ~ &quot;750-799&quot;, variable == &quot;B25063_018&quot; ~ &quot;800-899&quot;, variable == &quot;B25063_019&quot; ~ &quot;900-999&quot;, variable == &quot;B25063_020&quot; ~ &quot;1000-1249&quot;, variable == &quot;B25063_021&quot; ~ &quot;1250-1499&quot;, variable == &quot;B25063_022&quot; ~ &quot;1500-1999&quot;, variable == &quot;B25063_023&quot; ~ &quot;2000-2499&quot;, variable == &quot;B25063_024&quot; ~ &quot;2500-2999&quot;, variable == &quot;B25063_025&quot; ~ &quot;3000-3499&quot;, variable == &quot;B25063_026&quot; ~ &quot;3500-Inf&quot;, variable == &quot;B25063_027&quot; ~ &quot;DROP&quot; #No cash rent ), Estimate = estimate, MOE = stringr::str_c( &quot;+/- &quot;, scales::comma(moe, accuracy = 1) ) ) %&gt;% dplyr::filter(rent != &quot;DROP&quot;) %&gt;% tidyr::separate( rent, into = c(&quot;Bin_Min&quot;, &quot;Bin_Max&quot;), sep = &quot;-&quot; ) acs_rent %&gt;% DT::datatable() %&gt;% DT::formatCurrency(c(&quot;Bin_Min&quot;, &quot;Bin_Max&quot;), currency = &quot;$&quot;, digits = 0) %&gt;% DT::formatRound(c(&quot;Estimate&quot;), digits = 0) IPUMS provides the underlying microdata with the actual rent of each household, allowing this table to be re-binned. ipums_rent &lt;- readr::read_csv(&quot;./Data/nyc_micro_rent.csv&quot;) %&gt;% dplyr::transmute( household = SERIAL, HHWT, rent = dplyr::case_when( RENTGRS &lt; 500 ~ &quot;0-499&quot;, RENTGRS &lt; 1000 ~ &quot;500-999&quot;, RENTGRS &lt; 1500 ~ &quot;1000-1499&quot;, RENTGRS &lt; 2000 ~ &quot;1500-1999&quot;, RENTGRS &lt; 2500 ~ &quot;2000-2499&quot;, RENTGRS &lt; 3000 ~ &quot;2500-2999&quot;, RENTGRS &lt; 3500 ~ &quot;3000-3499&quot;, RENTGRS &lt; 4000 ~ &quot;3500-3999&quot;, RENTGRS &lt; 4500 ~ &quot;4000-4499&quot;, RENTGRS &lt; 5000 ~ &quot;4500-4999&quot;, RENTGRS &gt;= 5000 ~ &quot;5000-Inf&quot; ) ) %&gt;% dplyr::distinct(household, .keep_all = TRUE) %&gt;% srvyr::as_survey(weights = HHWT) %&gt;% dplyr::summarize( .by = rent, Estimate = srvyr::survey_total() ) %&gt;% dplyr::transmute( rent, Estimate, MOE = stringr::str_c( &quot;+/- &quot;, scales::comma(Estimate_se, accuracy = 1) ) ) %&gt;% tidyr::separate( rent, into = c(&quot;Bin_Min&quot;, &quot;Bin_Max&quot;), sep = &quot;-&quot; ) ipums_rent %&gt;% dplyr::arrange(as.double(Bin_Min)) %&gt;% DT::datatable() %&gt;% DT::formatCurrency(c(&quot;Bin_Min&quot;, &quot;Bin_Max&quot;), currency = &quot;$&quot;, digits = 0) %&gt;% DT::formatRound(c(&quot;Estimate&quot;), digits = 0) 6.1 Extracting Data IPUMS data is available online at https://usa.ipums.org/usa/. Register for an account and click Get Data to start. 6.1.1 Select Samples These are the datasets to pull from. 6.1.2 Select Geography Microdata available through IPUMS is only labeled at the PUMA-level and higher (roughly equivalent to Community Districts in NYC). Selecting geographic fields does not impact which records are sampled (a filter is required for that), it just provides a code in each record to aggregate the data to that level. 6.1.3 Select Variables IPUMS tries to harmonize variables across datasets, but make sure the variable(s) selected match the use-case and are available for all years. The metadata also provides info on top coding and other categorizations. 6.1.4 View Data Cart Ensure everything is correct, and then click Create Data Extract. 6.1.5 Modify Extract From this page you can: Change the file output to CSV Select cases (i.e. filter the sample) by state Adjust monetary values to 2010 6.1.6 Download Once the extract is completed, download the CSV. The download will likely show up as a .csv.gz file, so use 7-Zip to extract the zipped file instead of the default Windows option (Windows Explorer sometimes misinterprets .gz files and produces thousands of fragments). The data extract is now ready to use! readr::read_csv(&quot;./Data/nyc_micro_rent.csv&quot;) %&gt;% head() ## # A tibble: 6 x 12 ## YEAR SAMPLE SERIAL CBSERIAL HHWT CLUSTER STATEFIP COUNTYFIP STRATA GQ RENTGRS RENTGRS_CPIU_2010 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2023 202301 897328 2023000000170 85 2023008973281 36 47 430536 1 270 192 ## 2 2023 202301 897332 2023000000261 95 2023008973321 36 81 441336 1 417 296 ## 3 2023 202301 897332 2023000000261 95 2023008973321 36 81 441336 1 417 296 ## 4 2023 202301 897332 2023000000261 95 2023008973321 36 81 441336 1 417 296 ## 5 2023 202301 897332 2023000000261 95 2023008973321 36 81 441336 1 417 296 ## 6 2023 202301 897335 2023000000297 365 2023008973351 36 61 410336 1 1300 923 6.2 Analyzing a Survey Unlike the ACS, which provides cleaned estimates with margins of error, IPUMS is messy survey data that must be processed before producing estimates. However, unlike the NYC Housing and Vacancy Survey which has dozens of replicate weights to account for, IPUMS is much easier to work with. All that is needed is to create a survey object with the weight specified as either the household or person weight. IPUMS data is always provided at the person-level where each row represents a person. This is true even if all of the variables selected are household-level variables (in which case the household-level variables are repeated across all individuals in the household). When using person-level variables, use all records and the PERWT weight; when using household-level variables, first select only one row per household/SERIAL and then use the HHWT weight. #Household-level data ipums_hh_data %&gt;% #Select one row per household dplyr::distinct(SERIAL, .keep_all = TRUE) %&gt;% srvyr::as_survey(weights = HHWT) #Person-level data ipums_ind_data %&gt;% srvyr::as_survey(weights = PERWT) #Mixed data ipums_mix_data %&gt;% #Select specific row per household, in this case Head of Household dplyr::filter(RELATE == 1) %&gt;% srvyr::as_survey(weights = HHWT) Once the survey object is created, srvyr has a series of functions that calculate estimates with margins of error. survey_total() for counts survey_total(col) for sums survey_mean(col) for means survey_median(col) for medians survey_quantile(col, quantiles = x) for other quantiles Etc. readr::read_csv(&quot;./Data/nyc_micro_rent.csv&quot;) %&gt;% dplyr::distinct(SERIAL, .keep_all = TRUE) %&gt;% srvyr::as_survey(weights = HHWT) %&gt;% dplyr::summarize( median_rent = srvyr::survey_median(RENTGRS, na.rm = TRUE), mean_rent = srvyr::survey_mean(RENTGRS, na.rm = TRUE) ) %&gt;% DT::datatable() %&gt;% DT::formatCurrency(c(&quot;median_rent&quot;, &quot;median_rent_se&quot;, &quot;mean_rent&quot;, &quot;mean_rent_se&quot;), currency = &quot;$&quot;, digits = 2) When grouping, summarize() fails with multiple .by arguments, so multiple grouping variables should be concatenated before summarizing. readr::read_csv(&quot;./Data/nyc_micro_rent.csv&quot;) %&gt;% #Create new variables dplyr::transmute( household = SERIAL, HHWT, borough = dplyr::case_when( COUNTYFIP == 5 ~ &quot;Bronx&quot;, COUNTYFIP == 47 ~ &quot;Brooklyn&quot;, COUNTYFIP == 61 ~ &quot;Manhattan&quot;, COUNTYFIP == 81 ~ &quot;Queens&quot;, COUNTYFIP == 85 ~ &quot;Staten_Island&quot; ), rent = dplyr::case_when( .default = &quot;Normal&quot;, RENTGRS &lt; 500 ~ &quot;Very Low&quot;, RENTGRS &gt; 4000 ~ &quot;Very High&quot; ), RENTGRS ) %&gt;% #Concatenate variables into one column dplyr::transmute( household, HHWT, group = stringr::str_c(borough, rent, sep = &quot;-&quot;), RENTGRS ) %&gt;% dplyr::distinct(household, .keep_all = TRUE) %&gt;% srvyr::as_survey(weights = HHWT) %&gt;% #Group and analyze by the concatenated variable dplyr::summarize( .by = group, rent = srvyr::survey_median(RENTGRS, na.rm = TRUE) ) %&gt;% #Split the concatenated variable back into multiple variables tidyr::separate( group, into = c(&quot;borough&quot;, &quot;rent_level&quot;), sep = &quot;-&quot; ) %&gt;% dplyr::select(-rent_se) %&gt;% tidyr::pivot_wider(names_from = borough, values_from = rent) %&gt;% DT::datatable() %&gt;% DT::formatCurrency(c(&quot;Bronx&quot;, &quot;Brooklyn&quot;, &quot;Manhattan&quot;, &quot;Queens&quot;, &quot;Staten_Island&quot;), digits = 0) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
